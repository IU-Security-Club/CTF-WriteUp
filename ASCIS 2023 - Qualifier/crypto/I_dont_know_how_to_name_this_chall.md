# ASCIS - I_dont_know_how_to_name_this_chall

### Context
We have 2 files which are chall.sage and output.txt: \
**chall.sage**
```py
from Crypto.Random.random import getrandbits
from Crypto.Util.number import bytes_to_long

nbits = 128
while True:
    mul = getrandbits(nbits)
    add = getrandbits(nbits)
    modulus = getrandbits(nbits)
    if mul < modulus and add < modulus:
        break

def gen_num(bits):
    truncate = bits
    seed = getrandbits(511)
    gen_num = 41

    xx = []
    yy = [] 
    
    for _ in range(gen_num):
        seed = (mul * seed + add) % modulus
        xx.append(seed)
        yy.append(seed >> (nbits-truncate))
    return xx, yy

_, ee = gen_num(18) 
_, ff = gen_num(20)

a = ee[-1] 
b = ff[-1] 
c = getrandbits(1024)
p = next_prime(a * c + getrandbits(512)) 
q = next_prime(b * c + getrandbits(512)) 

flag = '<REDACTED>'
N = p * q
e = 65537
m = bytes_to_long(flag.encode())
enc = pow(m, e, N)

print(f'enc = {enc}')
print(f'N = {N}')
print(f'ee = {ee[:-1]}')
print(f'ff = {ff[:-1]}')
print(f'a = {mul}')
print(f'c = {add}')
print(f'm = {modulus}')
```
**output.txt**
```
enc = 4782207738169357679017263311695366580149461241803922088835452812820137537830281562950634059939171784035642202164746425519370563906663225547286363495366866588141853586109553019469599011984795232666657032457349167541183811442599555965876853759790930565452169138123206051344200109808603093521161556603615660329142949615063443855551027286822234646698015310643407246009689006200152818931447476595216569044114220319818061396623338764899012025923470408152189436065437542065068815744124506169026323905222443334212867601172364249248963768649488580249031694113977946046461290930755706144535271632419505875554486279354334709794323960679
N = 3964970058588757148381961704143056706462468814335020245520977895524549102412775370911197710398920529632256746343939593559572847418983212937475829291172342816906345995624544182017120655442222795822907477729458438770162855927353619566468727681852742079784144920419652981178832687838498834941068480219482245959017445310420267641793085925693920024598052216950355088176712030006651946591651283046071005648582501424036467542988971212512830176367114664519888193885765301505532337644978456428464159474089450883733342365659030987687637355512103402573155030916404165387863932234088255017821889649456947853403395704387479968208359004918561
ee = [167323, 194700, 130745, 7156, 65616, 200175, 106106, 4410, 94204, 121719, 176084, 168449, 206162, 19151, 165232, 149276, 151372, 64105, 162906, 92391, 69021, 200382, 22272, 14195, 200195, 70505, 46059, 194712, 177080, 209749, 112239, 9882, 23285, 45783, 117745, 31663, 51641, 148822, 169539, 142669]
ff = [300710, 494582, 107979, 208491, 285026, 638043, 525064, 566864, 36622, 212388, 374138, 220683, 193612, 532230, 75887, 548412, 650282, 195040, 74550, 158762, 797511, 322315, 821880, 484339, 76864, 64394, 101586, 815915, 762307, 410750, 115213, 726390, 378350, 800132, 379035, 797320, 413506, 284265, 537835, 226489]
a = 43787291635671214792919526096167649451
c = 156497500579206068939331641182566791023
m = 273364800599018888270443304662600024273
```
At first sight, we see that ```gen_num(bits)``` function using Linear congruential generator to generate a series of random numbers and then shift it by some bits and print to the output. In order to factor N, we might want to find a and b, which are the last number of array **ee** and **ff**.<br>
Luckily, I found a tool that help me to find complete numbers in the array **ee** and **ff**. <br>

```py
#https://github.com/jvdsn/crypto-attacks/blob/master/attacks/lcg/truncated_parameter_recovery.py
ee = [167323, 194700, 130745, 7156, 65616, 200175, 106106, 4410, 94204, 121719, 176084, 168449, 206162, 19151, 165232, 149276, 151372, 64105, 162906, 92391, 69021, 200382, 22272, 14195, 200195, 70505, 46059, 194712, 177080, 209749, 112239, 9882, 23285, 45783, 117745, 31663, 51641, 148822, 169539, 142669]
mul = 43787291635671214792919526096167649451
c = 156497500579206068939331641182566791023
m = 273364800599018888270443304662600024273
k=128
s=18
full_ee=attack(ee,k,s,m,mul,c)
a=((full_ee[-1]*mul+c)%m)>>(128 - 18)
print(f"a = {a}")

ff = [300710, 494582, 107979, 208491, 285026, 638043, 525064, 566864, 36622, 212388, 374138, 220683, 193612, 532230, 75887, 548412, 650282, 195040, 74550, 158762, 797511, 322315, 821880, 484339, 76864, 64394, 101586, 815915, 762307, 410750, 115213, 726390, 378350, 800132, 379035, 797320, 413506, 284265, 537835, 226489]
mul = 43787291635671214792919526096167649451
c = 156497500579206068939331641182566791023
m = 273364800599018888270443304662600024273
k=128
s=20
full_ee=attack(ff,k,s,m,mul,c)
b=((full_ee[-1]*mul+c)%m)>>(128 - 20)
print(f"b = {b}")
```
We will have ``a = 182536`` and ``b = 732597``.<br>
In 
```py
c = getrandbits(1024)
p = next_prime(a * c + getrandbits(512)) 
q = next_prime(b * c + getrandbits(512))
```
It's easy to see that ``p ≈ a*c`` and ``q ≈ b*c``.<br>
We will have ``p*b ≈ q*a``, ``N = pq`` so ``N ≈ p^2*b/a``<br>
=> ``p ≈ sqrt(a*N/b)`` <br><br>
I will set ``pbar = sqrt(a*N/b)``<br>
=> **pbar** will have some MSBs that equal to **p** <br>
From here, I will use coppersmith method to factor N with high bits of p assuming around 500 low bits is unknow and increase until find the root.
```py
#https://github.com/mimoo/RSA-and-LLL-attacks
load('coppersmith.sage')

a=182536
b=732597
n=3964970058588757148381961704143056706462468814335020245520977895524549102412775370911197710398920529632256746343939593559572847418983212937475829291172342816906345995624544182017120655442222795822907477729458438770162855927353619566468727681852742079784144920419652981178832687838498834941068480219482245959017445310420267641793085925693920024598052216950355088176712030006651946591651283046071005648582501424036467542988971212512830176367114664519888193885765301505532337644978456428464159474089450883733342365659030987687637355512103402573155030916404165387863932234088255017821889649456947853403395704387479968208359004918561

pbar=int(sqrt((n*a)//b))
lbits=500
while True:
    ln = 2^lbits
    p_length=1042
    q_length=1044
    p_high=pbar//ln

    p0=p_high

    # Recovery starts here
    q0 = floor(n / (p0*ln))//ln
    print("q0 bit lengths: ", len(bin(q0))-2)
    X = Y = 2^(lbits+2) # bounds on x0 and y0


    bounds = (X,Y)
    R = Integers(n)
    PR.<x, y> = PolynomialRing(Zmod(n))

    f = (x+p0*ln)*(y+q0*ln)

    r=small_roots(f, bounds)
    if r == []:
        lbits = lbits + 1
        continue
    print(small_roots(f, bounds))

    print("p = ", p0*ln+r[0][0])
    break
```
After p being found, decrypt cipher text is easier than ever:
```py
p=31431249988172282588448767875539383078270520610885068858894594350040664294089631831898187839710370441685270767030754635557928414643087264016495427842079478763643907923013313402216294673271331719335552788028954573534461929535970634245151789537569696550609948093753009761080068097372824084476376283889917608424955747
q=N//p
phi=(p-1)*(q-1)

d=pow(e,-1, phi)

print(long_to_bytes(pow(enc,d,n)))
```
```
b'ASCIS{S0rry_1_caNt_make_a_b3tt3r_Crypt0_ch4ll}'
``` 
